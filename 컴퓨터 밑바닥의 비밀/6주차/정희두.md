### Summary

2의 보수를 이해하고 자바의 비트 연산에 익숙해져보자.

### Concept

### 🚀 알고가자!

**1의 보수**

모든 비트를 1로 만들 수 있는 수

- 1001의 보수는 0110

**2의 보수**

모든 비트를 1로 만들 수 있는 수에 1을 더한 수

- 1001의 1의 보수는 0110 여기에 1을 더한 수 0111

컴퓨터의 수 체계는 무조건 0과 1로 표현한다.

숫자 5 == 00000101

숫자 5 + 5 == 00000101 + 00000101 ⇒ 00001010

### 🚀 그렇다면 5 - 5는 어떻게 계산할까?

우선 음수를 표현하는 방식을 알아야한다.

컴퓨터는 -5를 어떻게 표현할까?

(1의 보수가 중요한데 1의 보수는 회로 설계에서 효율적이지도 않고 직관적이지 않아서 건너뛸게요)

1의 보수의 단점인 0이 (0과 -0) 두가지로 표시할 수 밖에 없는 단점이 있다.

그래서 계산 방식이 조금 덜 직관적인 2의 보수를 사용한다. 그리고 2의 보수가 회로 설계 상 유리하다고 한다.

1. 단일 덧셈 회로 사용 가능 : 2 + (-2) → CPU는 2와 2의 보수를 더할 뿐이다.
2. 0의 유일한 표현으로 작업 단순화와 대칭성 제공한다.(예층 가능성이 더 좋음)

2의 보수 계산 방식은 특정 숫자 1의 보수에 더하기 1을 하는 것.

4의 1의 보수 ⇒ 0100 → 1011 + 1 ⇒ 1100

우리가 이렇게 2의 보수를 알면 좋은 이유는 비트 연산 방식의 가장 기본이기 때문이다. 

### 🚀 그럼 우리는 비트 연산 방식을 왜 알아야할까?

비트연산의 효율성은 주로 연산 속도에 있다. 우리는 고급 프로그래밍 언어를 사용하기 때문에 컴파일을 통해 기계어로 번역이 필요하다. 이 기계어도 CPU가 다이렉트로 이해하기 어렵다.

비트는 0과 1로 이루어져있기 때문에 CPU가 이해하기 무리가 없다. 그 비트를 가지고 연산을 하기 때문에 성능면에서는 좋다.

대표적인 예로 알고리즘에 비트 마스킹 알고리즘이 있고 다른 영역에서는 암호화, 데이터 압축, 프로토콜 헤더 변환 등 컴퓨팅 성능적 우위를 두어야하는 곳에서 많이 활용되고 있다.

### 🚀 자바의 비트연산

🍎 AND 연산

두 수를 이진수로 변환하고 각 이진수 자리를 매치 시켰을 때 둘다 1이면 1로 두고 하나라도 1이 아니면 0으로 변경

9와 11 → 이진수 변환 → 1001와 1011 

9 & 11 → 1001 & 1011 → 1001

🍎 OR 연산

두 수를 이진수로 변환하고 각 이진수 자리를 매치 시켰을 때 둘다 1이면 1로 두고 하나라도 1이 이면 1로 변경

9와 11 → 이진수 변환 → 1001와 1011 

9 | 11 → 1001 | 1011 → 1011

🍎 XOR 연산(^)

각 자리수가 다르면 1 같으면 0 

9와 11 → 이진수 변환 → 1001와 1011 

9 ^ 11 → 1001 ^ 1011 → 0010

🍎 NOT 연산(~)

하나의 숫자의 이진수의 각자리수를 반대로 바꾸는 것 

9 → 1001

~9 → ~1001 → 0110

🍎 Shift 연산(<<, >>)

- << 연산
    - 이진수 각 자리를 왼쪽으로 N칸 밀고 제일 첫째자리는 0으로 채워주는 연산
    - 3 << 2 → 3의 이진수를 2칸 왼쪽으로 이동시킴
    - 011 << 2 → 01100
- >> 연산
    - 이진수의 각자리를 오른쪽으로 N칸 밀고 밀면서 사라지는 자리수는 삭제해버린다.
    - 16 >> 3 → 16의 이진수를 3칸 오른쪽으로 이동시킨다.
    - 10000 >> 3 → 00010
- >>> 연산
    - 오른쪽으로 미는데 무조건 양수만 고려하겠다는 말
    - 오른쪽으로 밀고 나머지는 모두 0으로 변환

### 참고

https://www.tcpschool.com/c/c_operator_bitwise#google_vignette

https://f-lab.kr/insight/bit-operation-efficiency-and-principles

https://vmpo.tistory.com/106