# Summary
프로세스 (스레드) 와 동기화

# Concept

## 프로세스 (스레드)
프로그램이 메모리에 올라가서 실행 중 -> 프로세스   
프로세스의 일의 흐름 -> 스레드   
차이점
* 스레드는 프로세스의 자원을 공유한다.   (프로세스간에는 자원 공유 어려움)
* 스레드는 fork-exec 과정이 없어서 가볍다.

## 스레드 공유 자원
1. 코드 영역 : 모든 함수는 스레드로 실행이 가능해야하므로 코드 영역은 스레드가 접근할 수 있다. 하지만 read-only 이므로 스레드 안전 문제가 발생하지 않는다.
2. 데이터 영역
3. 힙 영역
4. 스택 영역 : 이 부분이 조금 특이, 스택 영역이 스레드 독자적인 공간이라고 생각할 수 있지만, **운영체제에 의해 프로세스간에는 주소 공간에 접근이 불가능하지만, 스레드는 그렇지 않다**   
5. 동적 링크 라이브러리 : **스택 영역과 힙영역 사에에 존재**

>
2,3,4 는 read-only가 아니므로 스레드 안전 문제가 발생한다.   

### 스레드 전용 저장소
```c++
    __thread int a = 1; // 스레드 전용 저장소
    int b = 1; // 전역 변수
```

## 스레드 안전성
> 스레드 몇 개에서 호출되든 이 스레드들이 어떤 순서로 호출되든 간에 상관없이 올바른 결과가 나온다면, 이 코드를 스레드 안전 (thread safety) 이라고 말한다.

스레드 전용 자원을 쓸 때에는, 안전성에 주의할 필요가 없다. (나만 접근하니까)
하지만 **스레드 공유 자원**을 쓸 때에는 안전성에 주의해야 한다. (다 같이 쓰니까)


> 매개변수 지역 변수 등 함수 안의 자원만 사용하는 경우 크게 주의할 필요가 없지만, 매개변수가 **포인터**인 경우에는 안전성에 주의해야 한다. (공유 자원을 가져온 것이므로)

## 스레드 사용 케이스
### 스레드 전용 자원
1. 스레드 전용 자원 (지역 변수 / 스레드 전용 저장소) 사용 : 안전, 무상태 함수 (지역 변수만 사용한 경우, 몇번 수행해도 같은 값)
2. 스레드 전용 자원과 함수 매개변수 : 매개 변수는 값 전달이므로 안전
> 하지만 매개 변수로 포인터를 전달한 경우는 안전 검사 필요 (공유 자원이므로)
> * 스레드 전용 자원의 포인터를 사용하면 안전
### 스레드 공유 자원
3. 전역 변수 사용 :
    1. 초기에 초기화 된 전역 변수를 읽기만 하면 안전
    2. 수정 하는 경우 반드시 **원자성** 설정 필요
> 원자성이란?    
> 원자적 연산이란, CPU 가 명령어 1 개로 처리하는 명령으로, 중간에 다른 쓰레드가 끼어들 여지가 전혀 없는 연산을 말합니다. 즉, 이 연산을 반 정도 했다 는 있을 수 없고 이 연산을 했다 혹은 안 했다 만 존재할 수 있습니다. 마치 원자처럼 쪼갤 수 없다 해서 원자적(atomic) 이라고 합니다.



4. 스레드 안전이 아닌 코드 호출 : mutex lock 등을 사용해서 앞뒤로 스레드 안전을 보장해야 한다.

## 스레드 안전성을 보장하는 방법
1. 스레드 전용 저장소
2. 읽기 전용
3. 원자성 연산
4. 동기화시 상호배제
    * 뮤텍스
    * 세마포어
    * 스핀 잠금

# 프로세스 동기화
* 실행 순서 제어 : 올바른 순서대로 실행하기
* 상호 배제 : 동시에 접근해서는 안되는 자원 (공유 자원)에 하나의 프로세스만 접근하게 하기
## 동기화 문제
### 실행 순서 제어
* Reader-Writer Problem
### 상호 배제
* Bank Account Problem
* Producer-Consumer Problem
## 경쟁 조건 (Race Condition)
* 2개 이상의 프로세스(스레드)가 공유 자원을 병렬적으로 읽거나 쓰는 상황
* 경쟁 조건이 발생하면 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있다.

## 임계 구역 (Critical Section)
* 공유 자원 접근 순서에 따라서 실행 결과가 달라지는 프로그램의 영역
### 임계 구역을 해결하는 방법
* 상호 배제 : 한 번에 한 프로세스만 임계 구역에 접근
* 진행 : 어떤 프로세스도 임계 구역에 들어가지 않았다면, 들어가고자 하는 프로세스는 임계 구역에 들어갈 수 있어야 한다.
* 유한 대기 : 어떤 프로세스가 임계 구역에 들어가고자 한다면, 언젠가는 임계 구역에 들어갈 수 있어야 한다.

## 동기화 방법
### 뮤텍스 락 : 자물쇠 (바쁜 대기)
```c++
acquire()
{
    while (lock == true) // 바쁜 대기
        ;
    lock = true;
}

release()
{
    lock = false;
}

func()
{
    acquire();
    // 임계 구역
    release();
}
```

### 세마포어 : 발전된 뮤텍스 락 (여러 공유 자원)
```c++
wait()
{
    while (S <= 0) // 바쁜 대기
        ;
    S--;
}

release()
{
    S++;
}

func()
{
    acquire();
    // 임계 구역
    release();
}
```

## 교착 상태
### 식사하는 철학자 문제 (Dining philosophers problem)
1. 일정 시간 생각을 한다.
2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
5. 오른쪽 포크를 내려놓는다.
6. 왼쪽 포크를 내려놓는다.
7. 다시 1번으로 돌아간다.
> 교착 상태란, 둘 이상의 프로세스가 서로 어떤 자원을 점유한 상태에서 점유할 수 없는 다른 자원을 기다리는 상태

### 교착 상태의 발생 원인

1. 상호 배제 : 한 번에 한 프로세스만 자원 점유 가능
2. 점유와 대기 : 자원을 할당 받은 상태에서 다른 자원을 기다림
3. 비선점 : 강제로 다른 프로세스의 자원을 빼앗을 수 없다.
4. 원형 대기 (자원 할당 그래프) : 프로세스들이 원의 형태로 자원을 기다림

**이 4가지 중 하나라도 만족시키지 못한다면 교착 상태가 발생하지 않는다.**

## 교착 상태를 해결하는 방법
1. 예방 : 아예 발생하지 않게 만들자
2. 회피 : 자원을 조심해서 할당하자
3. 검출 후 회복 : 찾으면 벗어나자

### 교착 상태 예방
1. 상호 배제 : 모든 자원을 공유하게 만든다. (이론상 불가능)
2. 점유와 대기 : 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않음 (자원 활용률이 낮아짐)
3. 비선점 : 자원을 선점 가능하게 만든다. (모든 자원이 선점 가능한 것은 아님)
4. 원형 대기 (자원 할당 그래프) : 자원에 우선순위를 둠 (우선 순위를 매기기 어려울 뿐 아니라, 낮은 우선 순위의 자원의 경유 활용률이 낮아짐)
> 교착 상태가 발생하지 않음은 보장할 수 있으나, 부작용이 따름

### 교착 상태 회피
* 안전 순서열 : 교착 상태 없이 안전하게 프로세스들에게 자원을 할당할 수 있는 순서
* 안전 상태 : 교착 상태 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태
* 불안전 상태 : 교착 상태가 발생할 수도 있는 상태

|프로세스| 요구량 | 현재 사용량 |
|:---:|:---:|:---:|
|P1|10|5|
|P2|4|2|
|P3|9|2|

할당 가능한 자원 : 12   
할당한 자원 : 9     
남은 자원 : 3   

안전 순서열 : P2->P1->P3


|프로세스| 요구량 | 현재 사용량 |
|:---:|:---:|:---:|
|P1|10|5|
|P2|4|2|
|P3|9|3|

할당 가능한 자원 : 12   
할당한 자원 : 10     
남은 자원 : 2   

안전 순서열 없음 -> 불안전 상태 -> 회피 불가

> 교착 상태 회피는 안전 상태에서 안전 순서열을 통해 다시 안전 상태로 가는 것

### 교착 상태 검출 후 회복
* 선점을 통한 회복 : 교착 상태가 해결될 때까지, 한 프로세스 씩 자원을 몰아줌
* 프로세스 강제 종료를 통한 회복
    * 교착 상태에 놓인 프로세스를 모두 종료 : 작업 내역을 잃을 위험
    * 교착 상태가 회복될 때까지 한 프로세스 씩 종료 : 오버헤드


# Reference
[모두의 코드](https://modoocode.com/271)   
[[OS] 공유 자원과 임계구역](https://velog.io/@suyeonme/OS-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD)