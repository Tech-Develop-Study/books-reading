## Summary
- 힙 영역에서 가비지 컬렉션(GC) 어떻게 발생할까

<br>

## Concept

### Garbage Collector 란
- 동적으로 할당된 메모리 영역 중 사용하지 않는 영역을 탐지하여 해체하는 기능
- 여기서 말하는 할당된 메모리는 **힙 영역** 의미
- 힙 영역의 Object를 가리키는 참조 변수가 Stack 할당

### 예제 코드

```java
public class Example {
    public static void main(String[] args) {
        int num1 = 10;
        int num2 = 5;
        String name = "김진성";

        System.out.println(num1);
        System.out.println(num2);
        System.out.println(name);
    }
}
```
- 현재 함수가 끝나게 되면 stack 있는 값들은 pop
- **“String 김진성”** 값은 GC 대상이 됨

<br>

### Garbage Collector 과정
1. Stack 모든 변수를 스캔하면서 어떤 객체를 참고하고 있는지 찾아서 마킹한다.
2. Heap 에서 참조하고 있는 객체도 찾아서 마킹한다.
3. 만약에 마킹되지 않는 객체가 있으면 Heap에서 제거한다.


이렇게 마킹을 하고 제거하는 것을 **Mark And Sweep**

<br>

### Garbage Collector 언제 일어날까?
일단, Heap 안에서 GC 발생하는데 Heap 내부 구조를 보면
- New Generation
    - Eden
    - Survival 0
    - Survival 1
- Old Generation

#### 일어나는 과정
1. Eden 객체 할당
2. Eden 공간 X -> GC 발생
3. Eden 살아남은 객체는 Survival 0 옮겨짐
4. 1,2번 반복
5. Survival 0 공간 X -> GC 발생 -> 살아남은 객체는 Survival 1 옮겨짐(Age 값 증가)
6. 1,2번을 반복
7. Survival 1 공간 X -> GC 발생 -> 살아남은 객체는 Survival 0 옮겨짐(Age 값 증가)
8. 이렇게 특정 Age 값이 되면 Old Generation 이동
9. Old Generation 꽉 차면 GC 발생

<br>

### 마무리
- 지금까지의 과정이 반복되면서 GC가 메모리 관리한다.
- 만약 java 애플리케이션에서 GC(Garbage Collection)가 발생하다가 Heap 영역이 꽉 차면, 애플리케이션은 OutOfMemoryError 오류를 발생시킵니다. 





