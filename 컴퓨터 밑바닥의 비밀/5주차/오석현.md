# 가상 메모리
가상 메모리 주소 공간은 물리 메모리에 사상(맵핑)되어 있다. 이것을 `페이지 테이블`이라고 한다.

프로세스의 주소 공간을 동일한 크기의 '조각'으로 나누고, 이 조각을 `페이지`라고 부른다.

두 프로세스가 동일한 메모리 주소에 기록하더라도 문제가 발생하지 않는 이유
> 메모리 주소가 가리키는 페이지가 서로 다른 물리 메모리 주소에 저장되기 때문

## [가상 메모리 링크](https://namoo-gamedev.tistory.com/28)

# 스택
## 함수 호출
함수 A가 함수 B를 호출하면 제어권(실제로 CPU가 어떤 함수에 속하는 기계 명령어를 실행하는지)가 넘어간다.
제어권이 이전될 때는
* 반환(return) : 어디에서 왔는지에 대한 정보 (함수 A의 기계 명령어가 어디까지 실행되었는지)
* 점프(jump) : 어디로 가는지에 대한 정보 (함수 B의 첫 번째 기계 명령어가 위치한 주소가 어딘지)

가 필요하다. 

점프는 기계 명령어에 
```
call 0x400540
```
처럼 메모리 주소를 호출하라는 식으로 이루어진다. 여기서 메모리 주소가 '어디로'를 나타낸다.

그리고 어디에서에 해당하는 (즉 새로 불린 함수가 실행을 마치고 돌아갈) 주소는 호출 스택 `아래에` 쌓인다. (스택은 메모리 상단에 위치하므로, 위에서 아래로 커짐, 즉 제일 위에 차곡차곡 쌓이는 방식)
> 그러므로 함수가 종료됐을 때 돌아갈 주소는, 호출 스택의 제일 아래를 확인하면 알 수 있다.

## 스택 프레임
* 매개 변수와, 지역 변수는 우선 레지스터에 저장되고, 레지스터가 모자르면 스택 프레임에 저장된다. (반환값은 레지스터에 저장됨) 

> 함수 A에서 함수 B로 점프가 이뤄질 때, 이 둘은 레지스터를 통해 필요한 정보를 공유한는구나

CPU가 함수 A에서 함수 B로 넘어간 뒤, 레지스터값을 덮어쓴다면 문제가 되지 않나?
> 이것도 스택에 저장된다. 가장 위, 즉 함수 A로 돌아왔을 때, 바로 꺼내서 레지스터 값을 복원하는데 사용된다.

이 즘에서 함수 A의 스택 프레임은

| 되돌려 놓을 레지스터 초깃값 |    
|:---:|
| 지역 변수 |   
| 매개 변수 ... |   
| 반환 주소 |

스택엔 이런 정보들이 저장된다. 하지만 스택의 공간은 한정되어 있으므로 그 이상 메모리를 저장하려 하면 `스택 넘침(stack overflow)`가 발생한다.
1. 너무 큰 지역 변수를 만들면 안된다.
2. 함수 호출 단계가 너무 많으면 안된다.


# 힙
## 힙 영역이 필요한 이유
스택 프레임은
* 함수가 종료되면 해당 함수의 스택 프레임은 무효화 되므로, 거기에 저장된 데이터를 사용해선 안된다.
* 스택 프레임의 생명 주기는 함수와 관련있으므로, 프로그래머가 신경쓰지 않아도 된다.
> 그렇다면, 여러 함수에 걸쳐 사용할 변수가 필요하고, 프로그래머가 생명 주기를 관리해야할 때는 어떻게 해야할까? 그래서 등장한 것이 <b>힙 영역</b>이다.

* 유휴 메모리 위치를 빠르게 찾아야 한다.
* 최대한 많은 메모리를 사용할 수 있어야 한다.
### 힙 영역에서 발생할 문제점
* 어떤게 비어있는 메모리인지 확인할 방법은?
    * 링크드 리스트를 사용하여 메모리를 할당할 때, 가장 처음 4바이트를 메모리의 크기와 사용 여부를 기록 (메모리 조각의 크기게 따라 다름) -> 헤더 / 페이로드
    * 힙 메모리 공간의 가장 마지막 (0/1) 로 메모리의 끝을 알려줌
* 비어 있는 메모리 중 어떤 걸 사용해야 할까?
    * 할당 전략
        * 최초 적합 : 가장 빠르지만 할당 후 여유 공간이 많이 남을 수 있다.
        * 다음 적합 : 최초 적합과 유사하지만, 최초 다음의 적합 메모리에 할당
        * 최적 적합 : 메모리를 모두 탐색 후, 가장 적합한 공간에 할당, 가장 느리지만 여유 공간이 남지 않음
* 할당한 뒤 남은 메모리 처리는?
    * 여유 공간이 발생 시, 해당 메모리를 모두 할당한다면 ? 내부 단편화
            * 사용하지 않는 메모리를 할당하여 나도 사용하지 않고, 다른 곳에서도 사용할 수 없는 상태
        > 그러므로, 할당하고 남은 공간을, 다시 나눠서 여유 메모리 조각으로 만든다.
* 해제한 뒤 반환된 메모리 처리는?  
    * 할당된 메모리에 해단 해제만 한다면, 반복된 메모리 할당과 해제로 조각들이 잘게 나눠져서 크기가 큰 메모리는 할당할 수 없게 된다.
    > 메모리 해제 시 뒤의 메모리도 탐색하여 비어있다면 메모리를 병합한다. (속도가 느려서 현재에는 조각 병합을 연기하는 전략 등을 사용)
    * 뒤로는 탐색할 수 있지만, 만약 해제되는 메모리 앞 공간이 비어 있는 경우에는?
        * 꼬리 정보(footer) 를 사용하여 헤더와 같은 내용을 담고 앞 공간의 메모리 사용여부 파악할 수 있게 한다. -> 양방향 연결 리스트 

## 계층
### 커널 (운영체제)
하드웨어나 메모리에 대한 직접 접근과 할당이 가능한 계층
### 유저 (프로그램)
커넓보다 제한적인 권한이 주어짐 (운영체제를 죽일 수 있으므로 제한)
### 시스템 호출
그렇다면 유저 계층에서 메모리를 직접 할당하고 해제할 수 있는 이유는 뭘까?
바로 시스템 호출 (System Call) 을 사용하여 커널 모드가 해당 작업을 수행하도록 함
### 표준 라이브러리
유저 모드에서 프로그래머가 이런 시스템 호출을 의식하지 않고 사용할 수 있는 이유는 표준 라이브러리에 감춰져 있기 때문이다.
### 시스템의 구조
|응용 프로그램|
|:---:|
|표준 라이브러리|
|운영체제|
|하드웨어|