**Summary**

- 약간의 링커를 곁들인 좀 더 자세한 컴파일러의 구조
- 결국 컴파일러는 기계어 실행파일을 만드는 프로그램

**Concept**

- 컴파일러는 고수준 언어를 저수준 언어로 변환해주는 프로그램
    - 이게 가장 주 목적이고 이 목적을 위해 더 최적화를 한다던가 구문 트리를 더 효율적으로 만든다던가 한다.
- 소스 파일이라는 먹이를 주면 실행 파일의 형태로 뱉어 준다.
    - 링커도 같은 역할을 하는데 그럼 컴파일러는 각 소스파일을 실행파일 형태로 만들어주고 링커는 이 실행파일들을 하나의 실행파일 형태로 만들어 준다고 생각하면될까? → 예를 들어 java의 jar 파일
- 컴파일러는 크게 전단부 후단부로 나뉜다.
    - 전단부 : 소스 프로그래밍 언어와 관계되는 부분으로 소스 파일을 분석하고 중간 코드를 생성하는 부분.
        - 각 언어마다 필요 → 이걸로 봐선 언어별로 어셈블리어 변환에 대한 책임이 있는 것 같다.
        - 구조
            - 어휘 분석기(**lexical analysis**) : 소스 파일에서 정해진 토큰 생성
                - 토큰 :  언어 설계자가 지정한 문법적 의미의 최소단위, 특수형태와 일반형태로 나뉨
                - 각 토큰은 언어에 따라 토큰 고유 번호를 가진다. 이는 효율적 처리를 위함임(== sequence_no)
                - 어휘 분석기는 토큰을 추출하고 해당 소스파일 내부에서 토큰에 할당된 추가 정보들을 가지고 있는다.
            - 구문 분석기(**syntax analyzer, parser**) : 해석기, 이를 통해 각 언어의 문법적 오류 체크
                - 두가지 행동 진행 → 문법 오류 체크, 의미 분석 체크
                - 특정 토큰 다음에 와야하는 토큰들의 규칙을 알고 있고 이 규칙에 따라 **구문 트리**를 만든다. 이를 어길시 **문법오류**(syntex error)가 발생(이건 토큰 규칙만 체크)
            - 의미 분석(**semantic** **analyzer**)을 말한다. 여기서 의미 분석이란 내가 생각하기에는 타입에 대한 이야기 같다. 각 토큰에 할당된 값들에 대한 규칙. 가령, 비교 토큰이 있을 때 비교되는 값들의 형식이 다르면 안되는 것들을 말하는 것 같다.
                - ⚠️ 의미 분석은 컴파일러를 만든 사람에 따라 독립적으로 가져갈 수도 있고 구문 분석단계에서 실행될 수도 있고 중간코드 생성과정에서 실행될 수도 있다.
                - 형 변환(type conversion), 의미 분석 단계에서 처리
                    - ex1) 대부분의 프로그래밍 언어에서는 실수가 배열의 첨자로 사용되었을 때 에러로 간주
                    - ex2) 어떤 언어에서는 실수와 정수의 혼합 연산을 허용하는데 이때는 연산을 수행하기 전에 정수를 실수로 바꾸어 주는 작업이 필요
            - 질문  : 의미 분석과 문법오류 체크는 뭐가 다를까?
            - 중간 코드 생성 : 각 언어의 구문 트리를 가지고 중간 코드를 만드는 단계. 중간코드는 어셈블리어로 변환된다.
    - 후단부 : 소스 언어보다는 목적 기계에 의존적이며 전단부에서 생성한 중간 코드를 특정 기계를 위한 목적 코드로 번역하는 부분
        - 목적 기계당 하나씩 필요 → CPU 기준으로 봤을 때 여러 종류의 CPU가 있는 상황을 말하는 것 같다. 책 부분의 통용, 문접이 만들어지는 기준이 될 것 같다.
        - 전단부 이후의 프로세스, 중간 코드에 대한 목적 프로그램이 생성됨
        - 하는 일
            - 목적 코드 생성 : 중간 코드를 입력으로 받아 그와 의미적으로 동등한 목적 기계에 대한 코드를 생성하는 일을 한다.
                - 적정 레지스터(캐시보다 연산장치에 더 가까운 저장소) 할당
                - 중간코드에 맞는 어셈블리어 생성
            - 코드 최적화
                - 지역 최적화({}블록 내부 행위), 전역 최적화
                - precode optimization(중간 코드에서 최적화), postcode optimization(목적 코드에서 최적화)

**Advantages**

- 컴파일하는 중 에러 발생 위치를 알 수 있을 것 같다.
- 컴파일의 최적화 대상이 되는 코드들을 안다면 코드 작성시 해당 유의하여 작성할 수 있을 것 같다.

**Disadvantages**

- 프로그래밍 언어를 개발할게 아니라면 컴파일러를 잘 안다고 우리가 할 수 있는 부분이 없다.


**Example Case**

추상 구문 트리 형식

```json
{
  "type": "Program",
  "start": 0,
  "end": 36,
  "body": [
    {
      "type": "FunctionDeclaration",
      "start": 0,
      "end": 36,
      "id": {
        "type": "Identifier",
        "start": 9,
        "end": 10,
        "name": "a"
      },
      "expression": false,
      "generator": false,
      "async": false,
      "params": [],
      "body": {
        "type": "BlockStatement",
        "start": 13,
        "end": 36,
        "body": [
          {
            "type": "ExpressionStatement",
            "start": 17,
            "end": 34,
            "expression": {
              "type": "CallExpression",
              "start": 17,
              "end": 33,
              "callee": {
                "type": "MemberExpression",
                "start": 17,
                "end": 28,
                "object": {
                  "type": "Identifier",
                  "start": 17,
                  "end": 24,
                  "name": "console"
                },
                "property": {
                  "type": "Identifier",
                  "start": 25,
                  "end": 28,
                  "name": "log"
                },
                "computed": false,
                "optional": false
              },
              "arguments": [
                {
                  "type": "Literal",
                  "start": 29,
                  "end": 32,
                  "value": "a",
                  "raw": "\"a\""
                }
              ],
              "optional": false
            }
          }
        ]
      }
    }
  ],
  "sourceType": "module"
}
출처: https://jake-seo-dev.tistory.com/124 [제이크서 위키 블로그:티스토리]
```

**Wrap-up**

- 컴파일러의 영역도 두가지 전단부, 후단부로 나뉜다는 것을 알게되었다.
- 컴파일러가 이런식으로 진행된다는 것정도만 알면 될 것 같습니다.
- 각 프로그래밍 언어마다 소스파일을 분석해서 구문트리를 만들고 어휘 분석을 하고 구문 분석을 진행합니다. 그리고 의미를 분석하고 어셈블리로 변경할 중간코드를 만듭니다. 그리고 각 기계에 따라 목적 코드를 생성합니다.
