### 🍎 주 아이디어

컬렉션의 순회 동작을 **반복자라는 별도의 객체**로 추출하는 것

- 일련의 데이터 집합에 대하여 순차적인 접근(순회)를 ‘지원’하는 패턴이다.
- 트리 같이 복잡하게 얽혀있는 자료 컬렉션들을 외부로 노출하지 않고 하나씩 순회하는 알고리즘 전략을 정의하는 것을 이터레이터 패턴이라고 한다.(아래 콜아웃과 비슷한 내용)
- 순회에 필요한 모든 세부 정보들(가령 데이터 집합에서 현재 위치, 남은 요소들, 총 길이)을 캡슐화하기 때문에 여러 반복자

컬렉션은 프로그래밍에서 가장 많이 사용되는 데이터 유형들 중 하나이긴 하지만, 객체 그룹의 단순한 컨테이너일 뿐이다.

컬렉션 안의 모든 원소들에 대한 접근 방식이 **공통화**되어 있다면 어떤 종류의 컬렉션에서도 이터레이터만 뽑아내면 여러 전략으로 순회가 가능해 보다 **다형적인 코드** 설계가 가능하다.

<aside>
💡 자바의 컬렉션 프레임워크에서 각종 컬렉션을 순회할 수 있는 것도 내부에 미리 이터레이터 패턴이 적용되어 있기 때문이다. 컬렉션 프레임워크의 컬렉션들은 이터레이터를 구현했기 때문에 내부 구조를 노출하지 않고도 모든 컬렉션에 대한 순회가 가능하다.

</aside>

### 🍎 구조 및 **컴포넌트의 역할**

![스크린샷 2024-06-12 오후 7.10.53.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fhx%2Fcywc6wv56093h6kwl4_h3cdr0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_OICs59%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-06-12%20%EC%98%A4%ED%9B%84%207.10.53.png)
1. **반복자 인터페이스** : 반복자를 사용할 Public API들의 Spec
2. **구상 반복자들** : 반복자 인터페이스의 구현체들로 구체적인 반복 알고리듬을 구현한 객체, 구현체는 현재 순회 진행 상황을 자체적으로 추적해야한다.
3. **컬렉션 인터페이스** :  컬렉션이 ‘반복자’를 호출할 수 있는 컬렉션임을 명시, 반복자를 가져오기 위한 하나 이상의 메서드가 있어야한다.
4. **구현 컬렉션** : 실제 사용하는 구현 컬렉션 클래스이다. 이 클래스는 ‘반복자’ 구현체를 반환할 수 있는 컬렉션이다.
5. **클라이언트** : 반복자 인터페이스, 컬렉션 인터페이스만 사용함, 따라서 구현 클래스로부터 의존성이 떨어진다. 클라이언트와 구현체가 약속(인터페이스)만 잘 지키면 구현의 변경에 대하여 한쪽의 변경만 확인하면 된다.

### 🍎  사용시기

- 컬렉션에 상관 없이 객체 순회 접근 방식을 통일하고자 할 때
- 컬렉션을 순회하는 다양한 방법을 지원하고 싶을 때
- 컬렉션의 복잡한 내부 구조를 클라이언트로 부터 숨기고 싶은 경우(편의 + 보안)
- 데이터 저장 컬렉션 종류가 변경 가능성이 있을 때

### 🍎  장점

- 일관된 이터레이터 인터페이스를 사용해 여러 형태의 컬렉션에 대해 동일한 순회 방법을 제공한다.
- 컬렉션 내부 구조 및 순회 방식을 알지 않아도 된다.
- 집합체의 구현과 접근하는 처리 부분을 반복자 객체로 분리해 결합도를 줄 일 수 있다.
    - 사용자가 해당 필드에 직접 접근하는게 아니라 Iterator를 호출해서 접근하기 때문에 공개API에만 접근하게된다. 그래서 내부 구현의 변경과는 전혀 연관성이 없어진다.
- 순회 알고리즘을 별도의 반복자 객체에 추출하여 각 클래스의 책임을 분리하기 때문에 **단일 책임 원칙**을 준수한다고 볼 수 있다.
- 데이터 저장 컬렉션의 정류가 변경되어도 클라이언트 구현 코드는 손상되지 않아 수정에는 닫히게 된다. 따라서 **개방 폐쇄 원칙**을 준수한다고 볼 수 있다.

### 🍎 단점

굳이 안만들어도 되는 상황이 많다. 자바의 경우 이미 구현이 되어 있다.(많은 언어들이 동일하다.)

### 🍎 예시코드

```java
class FacebookIterator implements ProfileIterator {
    // 반복자는 순회하는 컬렉션에 대한 참조가 필요합니다.
    private field facebook: Facebook
    private field profileId, type: string

    // 반복자 객체는 다른 반복자들과 별도로 컬렉션을 순회합니다. 따라서 반복자
    // 상태를 저장해야 합니다.
    private field currentPosition // 
    private field cache: array of Profile

    constructor FacebookIterator(facebook, profileId, type) is
        this.facebook = facebook
        this.profileId = profileId
        this.type = type
        // 여기서 초기화하지 않는 이유는 뭘까?

    private method lazyInit() is
        if (cache == null)
            cache = facebook.socialGraphRequest(profileId, type)

    // 각 구상 반복자 클래스는 공통 반복자 인터페이스를 자체적으로 구현합니다.
    method getNext() is
        if (hasMore()) // 체이닝
            result = cache[currentPosition]
            currentPosition++
            return result

    method hasMore() is
        lazyInit() // 현재 iteration할 데이터가 null일 경우 초기화 후 상태 비교
        return currentPosition < cache.length
}
```

https://refactoring.guru/ko/design-patterns/iterator