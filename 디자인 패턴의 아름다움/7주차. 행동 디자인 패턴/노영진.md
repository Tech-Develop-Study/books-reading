## Summary

- 중재자 패턴 개념도 여러 곳에서 쓰이고 있겠구나!

<br />

## Concept

**중재자 패턴이란?**

- 목적
  - 객체들이 직접 통신하지 않고 중재자(Mediator) 객체를 통해서 통신하도록 하여 객체 간의 상호작용을 중앙에서 관리하는 패턴
- 구조
  - Mediator: 객체 간의 상호작용을 관리하고 조정하는 객체. 모든 통신을 중재자가 처리
  - Colleague: 중재자를 통해 통신하는 객체들. 중재자를 통해서만 다른 객체들과 상호작용합

## Example

```
const mediator = () => {
  const mediator = () => {
    this.participants = [];
  }

  mediator.prototype.register = (participant) => {
    this.participants.push(participant);
  };

  mediator.prototype.deliver = (sender, message) => {
    this.participants.forEach(function(participant) {
      if (participant !== sender) {
        console.log(sender + '님이 ' + participant + '님에게 "' + message + '"라고 말합니다.');
      }
    });
  };

  return Josephus;
};

const 영진중재자 = new mediator();

영진중재자.register('현수');
영진중재자.register('지우');
영진중재자.deliver('현수', '우리 땅에서 물러가라!');
영진중재자.deliver('지우', '네놈들을 멸망시켜주겠다!');
```

</br>

### 옵저버 패턴 vs 중재자 패턴

|   특성    |                    옵저버 패턴                    |                      중재자패턴                      |
| :-------: | :-----------------------------------------------: | :--------------------------------------------------: |
|  결합도   |          느슨한 결합 (주체와 옵저버 간)           |            느슨한 결합 (객체와 중재자 간)            |
| 상호작용  |        주체의 상태 변화를 옵저버에게 통보         |       객체 간의 모든 상호작용을 중재자가 관리        |
|  확장성   |             새로운 옵저버를 쉽게 추가             |      새로운 객체를 추가하기 쉬움, 중재자만 수정      |
|  복잡성   | 다수의 옵저버가 있을 경우 관리가 복잡해질 수 있음 |              중재자가 복잡해질 수 있음               |
| 성능 문제 |      많은 옵저버가 있을 경우 성능 저하 가능       |            중재자에 과부하가 걸릴 수 있음            |
| 중앙 관리 |                  중앙 관리 없음                   |               상호작용을 중앙에서 관리               |
| 사용 사례 |           이벤트 핸들링, 상태 변화 통보           | 채팅 시스템, 항공 교통 관제, 컴포넌트 간의 통신 관리 |

#### 👀 관리가 복잡해질 수 있다는 의미

1. 옵저버 패턴

- 다수의 옵저버가 있을 경우 관리가 복잡해질 수 있다는 말은 주체(Subject)가 여러 옵저버(Observer)를 관리하고, 각 상태 변경마다 모든 옵저버에게 통보해야 하는 상황을 의미
  - **상태 변경 통보**: 주체가 상태를 변경할 때마다 모든 옵저버에게 이를 통보해야 합니다. 옵저버가 많을수록 이 과정이 복잡해짐.
  - **상태 동기화**: 주체와 여러 옵저버 간의 상태 동기화가 필요하며, 이를 적절하게 관리하지 않으면 일관성 문제가 발생할 수 있음.
  - **메모리 관리**: 다수의 옵저버가 있을 때 주체가 모든 옵저버를 유지하고 관리하는 데에 추가적인 메모리와 처리 능력이 요구됨.

1. 중재자 패턴

- 중재자가 복잡해질 수 있다는 말은 중재자(Mediator)가 여러 객체(Colleague) 간의 모든 상호작용을 관리해야 하는 상황을 의미.
  - **중앙 관리**: 중재자는 모든 객체 간의 상호작용을 중앙에서 관리합니다. 객체 간의 통신이 많아질수록 중재자가 관리해야 할 상호작용이 증가하여 복잡해짐.
  - **상태와 로직**: 중재자는 모든 객체의 상태와 로직을 알고 있어야 하므로, 객체의 수와 상호작용의 복잡성에 따라 중재자의 코드가 복잡해질 수 있음.
  - **성능 문제**: 중재자가 모든 통신을 처리해야 하므로, 복잡성이 증가함에 따라 성능 저하가 발생할 수 있음.

#### 👀 중재자에 과부하가 걸리는 상황

1. 많은 객체
   - 시스템에 많은 객체가 존재하고, 이 객체들이 빈번하게 상호작용할 때 중재자는 모든 상호작용을 관리해야 함. 예를 들어, 많은 사용자가 실시간으로 상호작용하는 채팅 시스템에서는 중재자가 모든 메시지를 처리하고 라우팅해야 함.
2. 복잡한 상호작용
   - 객체 간의 상호작용이 복잡하고 다양한 로직이 필요한 경우 중재자는 이러한 복잡한 로직을 모두 처리해야 함. 예를 들어, 항공 교통 관제 시스템에서 여러 항공기의 경로를 조정하고 충돌을 방지하는 로직이 중재자에 집중될 수 있음.
3. 높은 빈도의 통신
   - 객체들 간의 통신 빈도가 매우 높은 경우 중재자는 많은 요청을 처리해야 함. 예를 들어, 주식 거래 시스템에서 여러 주식의 가격이 실시간으로 변동되고, 많은 거래 요청이 발생할 경우 중재자가 모든 거래 요청을 관리해야 함.
4. 단일 장애점
   - 중재자가 과부하를 견디지 못하고 실패할 경우, 전체 시스템의 상호작용이 중단될 수 있음. 이는 중재자가 단일 장애점(Single Point of Failure)이 될 수 있음을 의미.
